SERVICE FLOW AND EXECUTION PATH
================================

1. APPLICATION STARTUP FLOW
===========================

1.1 Service Startup Sequence
----------------------------
    1. Eureka Server (8761)
       â””â”€â”€ Start first, wait for "Started EurekaServerApplication"

    2. API Gateway (8080)
       â””â”€â”€ Start after Eureka is ready
       â””â”€â”€ Registers with Eureka
       â””â”€â”€ Loads routing configuration

    3. Business Services (start in any order after Gateway)
       â”œâ”€â”€ Auth Service (8081)
       â”œâ”€â”€ User Service (8082)
       â”œâ”€â”€ Transaction Service (8083)
       â””â”€â”€ Balance Service (8084)

1.2 Individual Service Startup Flow
-----------------------------------
    Service Startup:
    â”œâ”€â”€ Load application.yml configuration
    â”œâ”€â”€ Initialize Spring Context
    â”œâ”€â”€ Connect to MySQL database
    â”œâ”€â”€ Create/update database tables (Hibernate DDL)
    â”œâ”€â”€ Register with Eureka Server
    â”œâ”€â”€ Start embedded Tomcat server
    â”œâ”€â”€ Health check endpoints become available
    â””â”€â”€ Service ready to accept requests

Example Console Output:
    "ğŸ” Starting Authentication Service..."
    "âœ… Auth Service started successfully!"
    "ğŸŒ Service available at: http://localhost:8081"

2. REQUEST PROCESSING FLOW
==========================

2.1 Client Request Journey
--------------------------
    Client Request
        â†“
    API Gateway (Port 8080)
        â”œâ”€â”€ CORS handling
        â”œâ”€â”€ Route matching (/api/auth/** â†’ auth-service)
        â”œâ”€â”€ Load balancing (if multiple instances)
        â””â”€â”€ Forward to target service
        â†“
    Target Service (e.g., Auth Service)
        â”œâ”€â”€ Spring Security filter chain
        â”œâ”€â”€ JWT token validation (if required)
        â”œâ”€â”€ Controller method execution
        â”œâ”€â”€ Service layer business logic
        â”œâ”€â”€ Repository/Database operations
        â””â”€â”€ Response formation
        â†“
    Response back through Gateway
        â†“
    Client receives response

2.2 Detailed Request Flow Example (User Registration)
----------------------------------------------------
    1. Client POST /api/auth/register
       â””â”€â”€ Body: {"email": "user@test.com", "password": "pass123", "name": "User"}

    2. API Gateway Processing
       â””â”€â”€ Route: /api/auth/** â†’ lb://auth-service
       â””â”€â”€ Strip prefix: /api/auth/register â†’ /register
       â””â”€â”€ Forward to: http://auth-service-instance/register

    3. Auth Service Processing
       â”œâ”€â”€ AuthController.register() method invoked
       â”œâ”€â”€ @Valid annotation triggers request validation
       â”œâ”€â”€ AuthService.register() business logic
       â”‚   â”œâ”€â”€ Check if user already exists
       â”‚   â”œâ”€â”€ Encrypt password with BCrypt
       â”‚   â”œâ”€â”€ Save user to database
       â”‚   â””â”€â”€ Generate JWT token
       â””â”€â”€ Return AuthResponse with token

    4. Response Journey
       â””â”€â”€ AuthController returns ResponseEntity
       â””â”€â”€ Gateway forwards response to client
       â””â”€â”€ Client receives JWT token

3. AUTHENTICATION FLOW
======================

3.1 User Registration Flow
-------------------------
    POST /api/auth/register
        â†“
    AuthController.register()
        â†“
    @Valid validation (email, password, name)
        â†“
    AuthService.register()
        â”œâ”€â”€ userRepository.existsByEmail() â†’ Check duplicates
        â”œâ”€â”€ passwordEncoder.encode() â†’ Hash password
        â”œâ”€â”€ userRepository.save() â†’ Save to database
        â”œâ”€â”€ jwtService.generateToken() â†’ Create JWT
        â””â”€â”€ return AuthResponse
        â†“
    HTTP 201 Created + JWT token

3.2 User Login Flow
------------------
    POST /api/auth/login
        â†“
    AuthController.login()
        â†“
    AuthService.login()
        â”œâ”€â”€ userRepository.findByEmail() â†’ Find user
        â”œâ”€â”€ passwordEncoder.matches() â†’ Verify password
        â”œâ”€â”€ jwtService.generateToken() â†’ Create new JWT
        â””â”€â”€ return AuthResponse
        â†“
    HTTP 200 OK + JWT token

3.3 Token Validation Flow
-------------------------
    Any Protected Endpoint Request
        â†“
    Extract "Authorization: Bearer <token>" header
        â†“
    authClientService.extractUserIdFromToken()
        â”œâ”€â”€ Remove "Bearer " prefix
        â”œâ”€â”€ Call authService.validateToken()
        â”‚   â”œâ”€â”€ jwtService.extractEmail()
        â”‚   â”œâ”€â”€ jwtService.extractUserId()
        â”‚   â”œâ”€â”€ jwtService.isTokenValid()
        â”‚   â””â”€â”€ userRepository.findByEmail() â†’ Verify user exists
        â””â”€â”€ Return userId for authorization

4. TRANSACTION CREATION FLOW
============================

4.1 Complete Transaction Flow
----------------------------
POST /api/transactions/
Authorization: Bearer <jwt-token>
    Body: {transaction details}
        â†“
    API Gateway â†’ Transaction Service
        â†“
    TransactionController.createTransaction()
        â”œâ”€â”€ authClientService.extractUserIdFromToken() â†’ Validate JWT
        â””â”€â”€ transactionService.createTransaction()
            â”œâ”€â”€ validateTransactionRequest() â†’ Business validation
            â”œâ”€â”€ calculateShares() â†’ Split amount based on type
            â”œâ”€â”€ Create individual transaction records
            â”œâ”€â”€ transactionRepository.saveAll() â†’ Save to database
            â””â”€â”€ Call Balance Service to update balances
                â†“
                RestTemplate call to balance-service/update
                â”œâ”€â”€ balanceService.updateBalance()
                â”œâ”€â”€ Find or create Balance entity
                â”œâ”€â”€ Update balance amount
                â””â”€â”€ balanceRepository.save()
        â†“
    Return List<TransactionResponse>

4.2 Split Calculation Logic
---------------------------
EQUAL SPLIT:
    totalAmount = â‚¹60, participants = 3
    â†’ Each person owes: â‚¹60 Ã· 3 = â‚¹20

EXACT SPLIT:
totalAmount = â‚¹60
    â†’ User1: â‚¹25, User2: â‚¹20, User3: â‚¹15
    â†’ Validation: â‚¹25 + â‚¹20 + â‚¹15 = â‚¹60 âœ“

PERCENTAGE SPLIT:
    totalAmount = â‚¹60
    â†’ User1: 50%, User2: 30%, User3: 20%
    â†’ Amounts: â‚¹30, â‚¹18, â‚¹12
    â†’ Validation: 50% + 30% + 20% = 100% âœ“

5. BALANCE MANAGEMENT FLOW
==========================

5.1 Balance Update Flow (Called by Transaction Service)
------------------------------------------------------
    Transaction Created
        â†“
    transactionService.createTransaction()
        â”œâ”€â”€ Save transaction to database
        â””â”€â”€ restTemplate.postForObject("http://balance-service/update", request)
            â†“
            BalanceController.updateBalance()
            â†“
            BalanceService.updateBalance()
                â”œâ”€â”€ Create balanceId = "user1_user2" (sorted)
                â”œâ”€â”€ Find existing balance or create new
                â”œâ”€â”€ Calculate balance change based on who paid/owes
                â”œâ”€â”€ Update balance amount
                â””â”€â”€ Save to database

5.2 Balance Calculation Logic
----------------------------
    Example: User1 pays â‚¹30 for User2
    balanceId = "1_2" (user1 < user2)
    Current balance.amount = 0

    Update logic:
    - User1 paid for User2
    - User2 now owes User1 â‚¹30
    - balance.amount = -30 (negative means User2 owes User1)

    From User1 perspective: getAmountForUser(1) = -30 (User1 is owed â‚¹30)
    From User2 perspective: getAmountForUser(2) = +30 (User2 owes â‚¹30)

5.3 Settlement Flow
------------------
POST /api/balances/settle
    Body: {payerId: 2, payeeId: 1, amount: 30}
        â†“
    BalanceController.createSettlement()
        â”œâ”€â”€ Validate JWT token
        â”œâ”€â”€ validateSettlementRequest()
        â”‚   â”œâ”€â”€ Check if payer actually owes money
        â”‚   â”œâ”€â”€ Check if amount doesn't exceed debt
        â”‚   â””â”€â”€ Validate minimum settlement amount
        â”œâ”€â”€ Create Settlement entity
        â”œâ”€â”€ settlementRepository.save()
        â””â”€â”€ updateBalanceFromSettlement()
            â”œâ”€â”€ Find related balance
            â”œâ”€â”€ Reduce balance amount by settlement amount
            â”œâ”€â”€ Auto-settle if balance < threshold
            â””â”€â”€ Save updated balance

6. SERVICE DISCOVERY FLOW
=========================

6.1 Service Registration
-----------------------
    Service Startup
        â†“
    @EnableDiscoveryClient annotation
        â†“
    Eureka Client Configuration
        â”œâ”€â”€ service-url: http://localhost:8761/eureka/
        â”œâ”€â”€ Application name from spring.application.name
        â””â”€â”€ Instance details (hostname, port, health URL)
        â†“
    Registration with Eureka Server
        â”œâ”€â”€ Send POST to /eureka/apps/{app-name}
        â”œâ”€â”€ Include instance metadata
        â””â”€â”€ Start sending heartbeats every 30 seconds

6.2 Service Discovery
---------------------
    Service Call (e.g., Transaction â†’ Balance)
        â†“
    RestTemplate with @LoadBalanced
        â†“
    URL: http://balance-service/update
        â”œâ”€â”€ Eureka Client intercepts request
        â”œâ”€â”€ Query Eureka for "balance-service" instances
        â”œâ”€â”€ Get list of available instances
        â”œâ”€â”€ Apply load balancing algorithm (round-robin)
        â””â”€â”€ Replace service name with actual IP:PORT
        â†“
    HTTP call to actual instance: http://192.168.1.100:8084/update

7. DATABASE INTERACTION FLOW
============================

7.1 JPA Repository Flow
----------------------
    Service Method Call
        â†“
    Repository Interface Method
        â†“
    Spring Data JPA Implementation
        â”œâ”€â”€ Query generation (if custom query)
        â”œâ”€â”€ Parameter binding
        â””â”€â”€ JDBC execution
        â†“
    Hibernate ORM
        â”œâ”€â”€ SQL query generation
        â”œâ”€â”€ Connection pool management
        â”œâ”€â”€ Transaction management
        â””â”€â”€ Result set mapping
        â†“
    MySQL Database
        â”œâ”€â”€ Query execution
        â”œâ”€â”€ Index usage
        â””â”€â”€ Result return
        â†“
    Entity objects returned to service

7.2 Transaction Management
-------------------------
    @Transactional Method
        â”œâ”€â”€ Begin database transaction
        â”œâ”€â”€ Execute business logic
        â”‚   â”œâ”€â”€ Multiple repository calls
        â”‚   â”œâ”€â”€ All operations in same transaction
        â”‚   â””â”€â”€ Rollback on any exception
        â”œâ”€â”€ Commit transaction (if successful)
        â””â”€â”€ Return result

8. ERROR HANDLING FLOW
======================

8.1 Exception Propagation
-------------------------
    Database Error
        â†“
    Repository throws DataAccessException
        â†“
    Service catches and wraps in BusinessException
        â†“
    Controller catches BusinessException
        â†“
    @ControllerAdvice GlobalExceptionHandler
        â”œâ”€â”€ Map exception to HTTP status
        â”œâ”€â”€ Create ErrorResponse object
        â””â”€â”€ Return ResponseEntity with error
        â†“
    API Gateway forwards error response
        â†“
    Client receives structured error

8.2 Circuit Breaker Flow (Future Enhancement)
--------------------------------------------
    Service Call to External Service
        â†“
    Circuit Breaker State Check
        â”œâ”€â”€ CLOSED: Normal operation, forward request
        â”œâ”€â”€ OPEN: Fail fast, call fallback method
        â””â”€â”€ HALF_OPEN: Test with single request
        â†“
    Track success/failure rates
        â”œâ”€â”€ Too many failures â†’ Open circuit
        â”œâ”€â”€ Successful requests â†’ Close circuit
        â””â”€â”€ Timeout â†’ Trigger fallback

9. MONITORING AND HEALTH CHECKS
===============================

9.1 Health Check Flow
--------------------
    GET /actuator/health
        â†“
    Spring Boot Actuator
        â”œâ”€â”€ Check database connectivity
        â”œâ”€â”€ Check disk space
        â”œâ”€â”€ Check external service dependencies
        â””â”€â”€ Aggregate health status
        â†“
    Return: {"status": "UP"} or {"status": "DOWN"}

9.2 Metrics Collection
---------------------
    Request Processing
        â”œâ”€â”€ Count requests per endpoint
        â”œâ”€â”€ Measure response times
        â”œâ”€â”€ Track error rates
        â””â”€â”€ Monitor JVM metrics (memory, threads)
        â†“
    Micrometer Metrics Registry
        â†“
    Export to monitoring systems (Prometheus, etc.)

10. DEVELOPMENT WORKFLOW
=======================

10.1 Code Change Deployment
---------------------------
    Code Change
        â†“
    mvn clean install (Build)
        â†“
    Service Restart
        â”œâ”€â”€ Graceful shutdown
        â”œâ”€â”€ Deregister from Eureka
        â””â”€â”€ Start with new code
        â†“
    Health Check Verification
        â†“
    Service Ready for Traffic

10.2 Testing Flow
----------------
    Unit Tests
        â”œâ”€â”€ Mock dependencies
        â”œâ”€â”€ Test business logic
        â””â”€â”€ Verify expected behavior
        â†“
    Integration Tests
        â”œâ”€â”€ Test with real database
        â”œâ”€â”€ Test service interactions
        â””â”€â”€ End-to-end scenarios
        â†“
    Manual Testing via Swagger UI
        â”œâ”€â”€ Test individual endpoints
        â”œâ”€â”€ Verify error handling
        â””â”€â”€ Test complete user journeys